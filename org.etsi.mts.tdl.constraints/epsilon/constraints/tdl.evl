import "../library/common.eol";
import "../library/helper.eol";
import "../library/debug.eol";

context NamedElement {
//Constraints
//Mandatory name
	constraint MandatoryName {
		check:	not self.name.oclIsUndefined() 
				and self.name.size() > 0
		message: self.prefix() + "A 'NamedElement' shall have the 'name' property set and the 'name' shall be not an empty String."
	}
//Distinguishable qualified names
	constraint DistinguishableName {
		//qualifiedName implementation pending, replace qualifiedName() with qualifiedName in end result
		check:  NamedElement.allInstances()->one(e | e.qualifiedName() = self.qualifiedName())
		message: self.prefix() + "All qualified names of instances of the same meta-class shall be distinguishable within a TDL model."
	}
}

context Package {
//Constraints
//No cyclic imports
	constraint CyclicImports {
		check: self.`import`->asOrderedSet()->closure(i | i.importedPackage.`import`)->forAll(i | i.importedPackage <> self)
		message: self.prefix() + "A 'Package' shall not import itself directly or indirectly."
	}
}


context ElementImport {
//Constraints
//Consistency of imported elements
	constraint ConsistentImports {
		check:  self.importedElement->forAll(e | self.importedPackage.packagedElement->contains(e))
		message: self.prefix() + "All imported 'PackageableElement's referenced by an 'ElementImport' shall be directly owned by the imported 'Package'."
	}
}

context Comment {
//Constraints
//No nested comments
	constraint CommentNestedComments {
		check:  self.comment->isEmpty()
		message: self.prefix() + "A 'Comment' shall not contain 'Comment's."
	}
//No annotations to comments
	constraint CommentNestedAnnotations {
		check:  self.annotation->isEmpty()
		message: self.prefix() + "A 'Comment' shall not contain 'Annotation's."
	}
}

context Annotation {
//Constraints
//No nested annotations
	constraint AnnotationNestedComments {
		check:  self.annotation->isEmpty()
		message: self.prefix() + "An 'Annotation' shall not contain 'Annotation's."
	}
//No comments to annotations
	constraint AnnotationNestedComments {
		check:  self.comment->isEmpty()
		message: self.prefix() + "An 'Annotation' shall not contain 'Comment's."
	}
}


context DataElementMapping {
//Constraints
//Restricted use of parameter mapping
    constraint ParameterMappingType {
        check:  self.parameterMapping.size() = 0
             or (self.mappableDataElement.oclIsTypeOf(StructuredDataType) 
             and self.parameterMapping->forAll(p | self.mappableDataElement.member->contains(p.parameter))) 
             or (self.mappableDataElement.oclIsKindOf(Action) 
             and self.parameterMapping->forAll(p | self.mappableDataElement.formalParameter->contains(p.parameter)))
        message: self.prefix() + "A set of 'ParameterMapping's shall only be provided if 'mappableDataElement' refers to a 'StructuredDataType', an 'Action' or a 'Function' definition and the 'mappableDataElement' contains the mapped 'Parameters'."
    }
}

context SimpleDataInstance {
//Constraints
//SimpleDataInstance shall refer to SimpleDataType
	constraint SimpleDataInstanceType {
		check:  self.dataType.oclIsKindOf(SimpleDataType)
		message: self.prefix() + "The inherited reference 'dataType' from 'DataInstance' shall refer to instances of 'SimpleDataType' solely."
	}
}

context StructuredDataType {
//Constraints
//Different member names in a structured data type
	constraint DistinguishableMemberNames {
		check:  self.member->forAll(m | self.member->one(e | e.name = m.name))
		message: self.prefix() + self.prefix()+"All 'Member' names of a 'StructuredDataType' shall be distinguishable."
	}

}

context StructuredDataInstance {
//Constraints
//StructuredDataInstance shall refer to StructuredDataType
	constraint StructuredDataInstanceType {
		check:  self.dataType.oclIsTypeOf(StructuredDataType)
		message: self.prefix() + "The inherited reference 'dataType' from 'DataInstance' shall refer to instances of 'StructuredDataType' solely."
	}
//'Member' of the 'StructuredDataType'
	constraint ExistingMemberOfDataType {
		check:  self.dataType.oclIsTypeOf(StructuredDataType) and self.memberAssignment->forAll(a | self.dataType.member->contains(a.member))
		message: self.prefix() + "The referenced 'Member' shall be contained in the 'StructuredDataType' that the 'StructuredDataInstance', which contains this 'MemberAssignment', refers to."
	}
}

context MemberAssignment {
//Constraints
//Type of a 'memberSpec' and 'Member' shall coincide 
	constraint MatchingMemberDataType {
		check:  self.memberSpec.getDataType() = self.member.dataType
		message: self.prefix() + "The 'DataType' of the 'StaticDataUse' of 'memberSpec' shall coincide with the 'DataType' of the 'Member' of the 'MemberAssignment'."
	}
//Restricted use of 'OmitValue' for optional 'Member's only
	constraint OmitValueUse {
		check:  (self.memberSpec.oclIsTypeOf(OmitValue) 
			  or self.memberSpec.oclIsTypeOf(AnyValueOrOmit)) 
		 implies self.member.isOptional = true
		message: self.prefix() + "A non-optional 'Member' shall have a 'StaticDataUse' specification assigned to it that is different from 'OmitValue' and 'AnyOrOmitValue'."
	}
//moved from StaticDataUse/DataInstanceUse
//Static data use in structured data	
	constraint StructuredDataInstanceUse {
		check: 	self.memberSpec.argument->forAll(a | a.dataUse.oclIsKindOf(StaticDataUse))
		 	and self.memberSpec.argument->closure(a | a.dataUse.argument)->forAll(a|a.dataUse.oclIsKindOf(StaticDataUse)) 
		message: self.prefix() + "If the 'memberSpec' refers to a 'StructuredDataInstance', all of its 'ParameterBinding's shall refer to 'StaticDataUse'."
	}
	
}


context DataUse {
//Constraints
//DELETED, redundant, already covered under function call
//No mixed use of 'Member' and 'FormalParameter' in 'argument' set
//All 'ParameterBinding's that are referenced in the 'argument' set shall refer only to one kind of 'Member' or 'FormalParameter'.
//Occurrence of 'argument' and 'reduction'
	constraint ArgumentReductionLists {
		//updated message from proposed change
		check: self.argument.isEmpty() or self.reduction.isEmpty() or self.oclIsTypeOf(FunctionCall)
		message: self.prefix() + "Only in case of a ‘FunctionCall' both the 'argument' list and the ‘reduction' list may be provided, otherwise either the 'argument' list, the ’reduction' list, or none of them shall be provided."
	}
//Structured data types in 'reduction' set
//A 'Member' at index i of a 'reduction' shall be contained in the 'StructuredDataType' of the 'Member' at index(i - 1) of that 'reduction'.
	constraint ReductionMembers {
		check: 	not self.getDataType().isKindOf(StructuredDataType)
				 or self.reduction->isEmpty()
				 or self.getDataType().member->contains(self.reduction->first())
				and self.reduction->select(m|
						self.reduction->indexOf(m) > 0)->forAll(m|
							self.reduction->at(self.reduction->indexOf(m)-1).dataType.isKindOf(StructuredDataType) 
						and self.reduction->at(self.reduction->indexOf(m)-1).dataType.member->contains(m))
		message: self.prefix() + "A 'Member' at index i of a 'reduction' shall be contained in the 'StructuredDataType' of the 'Member' at index(i - 1) of that 'reduction'."
	}

}

context ParameterBinding {
//Constraints
//Matching data type
	constraint ParameterBindingTypes {
		check:  self.dataUse.getDataType() = self.parameter.dataType
		message: self.prefix() + "The provided 'DataUse' shall match the 'DataType' of the referenced 'Parameter'."
	}
//Use of a 'StructuredDataInstance' with non-optional 'Member's
	constraint OmitValueParameter {
		check:  self.parameter.oclIsTypeOf(Member) 
			and self.parameter.oclAsType(Member).isOptional = false implies not self.dataUse.oclIsTypeOf(OmitValue) and not self.dataUse.oclIsTypeOf(AnyValueOrOmit)
		message: self.prefix() + "A non-optional 'Member' of a 'StructuredDataType' shall have a 'DataUse' specification assigned to it that is different from 'OmitValue'."
	}

}


context DataInstanceUse {
//Constraints
//Either argument list or reduction list provided
//	constraint DataInstanceUseArgumentReduction {
//		check:  self.argument->isEmpty() or self.reduction->isEmpty()
//		message: "Either one of the 'argument' list or 'reduction' list or none of them shall be provided."
//	}

//Moved
//Static data use in structured data
	//constraint StructuredDataInstanceUse {
		//check:  self.dataInstance.oclIsTypeOf(StructuredDataInstance) implies self.argument->forAll(a | a.dataUse.oclIsTypeOf(StaticDataUse))
		//message: self.prefix() + "If the 'DataInstance' refers to a 'StructuredDataInstance', all of its 'ParameterBinding's shall refer to 'StaticDataUse'."
	//}
	
	constraint DataInstanceOrArguments {
	    check:  not self.dataInstance.oclIsUndefined() or not self.argument->isEmpty()
	    message: self.prefix() + "Either a 'dataInstance' or a non-empty 'argument' set shall be specified."
	}

	constraint DataTypeInInteraction {
    	check:  (self.container().oclIsTypeOf(Interaction)
    		 and self.dataInstance.oclIsUndefined() 
    		 and not self.dataType.oclIsUndefined())
			 or (self.container().oclIsTypeOf(Interaction)
    		 and self.dataType.oclIsUndefined()
    		 and not self.dataInstance.oclIsUndefined()) 
			 or (self.dataType.oclIsUndefined()
			 and not self.container().oclIsTypeOf(Interaction))
	    message: self.prefix() + "The 'dataType' property shall be provided only if the 'DataInstanceUse' is directly contained in an 'Interaction' and no 'DataInstance' is referenced."
	}
}

context SpecialValueUse {
//Constraints
//Empty 'argument' and 'reduction' sets
	constraint SpecialValueUseArgumentReduction {
		//updated according to the discussion in Budapest
		// - AnyValue shall permit the optional 
		//   specification of arguments in case dataType is present (for use in interactions)
		// - AnyValue and AnyValueOrOmit shall permit the optional 
		//   specification of arguments
		check:  self.argument->isEmpty() 
			and self.reduction->isEmpty()
		message: self.prefix() + "The 'argument' and 'reduction' sets shall be empty."
	}
}

context AnyValue {
//Constraints
//Empty 'argument' and 'reduction' sets
//	constraint AnyValueArgumentReduction {
		//updated according to the discussion in Budapest
		// - AnyValue shall permit the optional 
		//   specification of arguments in case dataType is present (for use in interactions)
		// - AnyValue and AnyValueOrOmit shall permit the optional 
		//   specification of arguments
//		check: self.reduction->isEmpty()
//		message: self.prefix() + "The 'reduction' set shall be empty."
		//a separate constraint under interaction where the dataType shall be required in case arguments are provided, see Interaction
//	}
}

context AnyValueOrOmit {
//Constraints
//Empty 'argument' and 'reduction' sets
//	constraint AnyValueOrOmitArgumentReduction {
		//updated according to the discussion in Budapest
		// - AnyValue shall permit the optional 
		//   specification of arguments in case dataType is present (for use in interactions)
		// - AnyValue and AnyValueOrOmit shall permit the optional 
		//   specification of arguments
//		check:  self.reduction->isEmpty()
//		message: self.prefix() + "The 'reduction' set shall be empty."
//	}
}

context OmitValue {
//Constraints
//Empty 'argument' and 'reduction' sets
//	constraint OmitValueArgumentReduction {
		//updated according to the discussion in Budapest
		// - AnyValue shall permit the optional 
		//   specification of arguments in case dataType is present (for use in interactions)
		// - AnyValue and AnyValueOrOmit shall permit the optional 
		//   specification of arguments
//		check:  self.argument->isEmpty() 
//			and self.reduction->isEmpty()
//		message: self.prefix() + "The 'argument' and 'reduction' sets shall be empty."
//	}
}



context FunctionCall {
//Constraints
//Matching parameters
	constraint FunctionCallParameters {
		check:  self.`function`.formalParameter->forAll(p|self.argument->exists(a|a.parameter = p))
		message: self.prefix() + "All 'FormalParameter's of the 'Function' shall be bound."
	}
}

context FormalParameterUse {
//Constraints
//Either argument list or reduction list provided
//	constraint FormalParameterUseArgumentReduction {
//		check:  self.argument->isEmpty() 
//			 or self.reduction->isEmpty()
//		message: self.prefix()+"Either one of the 'argument' list or 'reduction' list or none of them shall be provided."
//	}
}


context VariableUse {
//Constraints
//Either argument list or reduction list provided
//	constraint VariableUseArgumentReduction {
//		check:  self.argument->isEmpty() 
//			 or self.reduction->isEmpty()
//		message: self.prefix()+"Either one of the 'argument' list or 'reduction' list or none of them shall be provided."
//	}
//Local variables of tester components only
	constraint VariableUseComponentRole {
		check:  self.componentInstance.type.variable->contains(self.variable)  
			and self.componentInstance.role.name = 'Tester'
		message: self.prefix()+"All variables used in a 'DataUse' specification via a 'VariableUse' shall be local to the same 'componentInstance' and the 'componentInstance' shall be in the role 'Tester'."
	}

}


context TimeLabelUse {
//Constraints
//Empty argument and reduction lists
//	constraint TimeLabelUseArgumentReduction {
		//not the same as above
//		check:  self.argument->isEmpty() 
//			and self.reduction->isEmpty()
//		message: self.prefix()+"The 'argument' and 'reduction' lists shall be empty."
//	}

}


context TimeConstraint {
//Constraints
//Time constraint expression of type Boolean
	constraint TimeConstraintType {
		check:  self.timeConstraintExpression.getDataType().name = 'Boolean'
		message: self.prefix()+ "The expression given in the 'DataUse' specification shall evaluate to predefined type 'Boolean'."
	}


//Use of local variables only
//  The expression given in the 'DataUse' specification shall contain only 'Variable's that are local to the 'AtomicBehaviour' that contains this time constraint. That is, all 'Variable's shall be referenced in the 'ComponentInstance' that executes the 'AtomicBehaviour'.
	constraint TimeConstraintVariables {
		//interaction: sourceGate.component, target.targetGate.component
		//actionBehaviour.componentInstance[0..1]
		check:	(not self.timeConstraintExpression.oclIsKindOf(VariableUse)
    	 	 	or (self.container().oclIsKindOf(Interaction)
    	 	  		and	(self.container().sourceGate.component = self.timeConstraintExpression.componentInstance 
    	 	   			or self.container().target->forAll(t | 
    	 	   				t.targetGate.component = self.timeConstraintExpression.componentInstance)))
    	 	 	or (self.container().oclIsKindOf(ActionBehaviour)
    	 	 		and not self.container().componentInstance.oclIsUndefined()
    	 	 		and self.container().componentInstance = self.timeConstraintExpression.componentInstance))
			 
    		 and self.timeConstraintExpression.argument->forAll(a | 
    		 		not a.dataUse.oclIsKindOf(VariableUse) 
		    	 	 or (self.container().oclIsKindOf(Interaction)
		    	 	 	 and (self.container().sourceGate.component = a.dataUse.componentInstance 
		    	 	       or self.container().target->forAll(t | 
    	 	   					t.targetGate.component = a.dataUse.componentInstance)))
		    	 	 or (self.container().oclIsKindOf(ActionBehaviour)
		    	 	     and not self.container().componentInstance.oclIsUndefined()
		    	 	     and self.container().componentInstance = self.timeConstraintExpression.componentInstance))
    		 	 
			 and self.timeConstraintExpression.argument->closure(a | a.dataUse.argument)->forAll(a | 
    	  	 		not a.dataUse.oclIsKindOf(VariableUse)
    	  	 		 or (self.container().oclIsKindOf(Interaction)
    	  	 		 	 and (self.container().sourceGate.component = a.dataUse.componentInstance 
		    	 	       or self.container().target->forAll(t | 
		    	 	   			t.targetGate.component = a.dataUse.componentInstance)))
		    	 	 or (self.container().oclIsKindOf(ActionBehaviour)
		    	 	     and not self.container().componentInstance.oclIsUndefined()
		    	 	     and self.container().componentInstance = self.timeConstraintExpression.componentInstance))
		
		message: self.prefix()+ "The expression given in the 'DataUse' specification shall contain only 'Variable's that are local to the 'AtomicBehaviour' that contains this time constraint. That is, all 'Variable's shall be referenced in the 'ComponentInstance' that executes the 'AtomicBehaviour'."
	}

}

context TimeOperation {
//Constraints
//Time operations on tester components only
	constraint TimeOperationComponentRole {
		check:	(not self.componentInstance.oclIsUndefined() 
				 and self.componentInstance.role.name = 'Tester') 
			 	 or (self.oclIsTypeOf(Quiescence) 
			 and not self.gateReference.oclIsUndefined() 
			 	 and self.gateReference.component.role.name = 'Tester') 
		message: self.prefix()+ "A 'TimeOperation' shall be performed only on a 'ComponentInstance' in the role 'Tester'."
	}
//'Time' data type for period expression
	constraint TimePeriodType {
		check:  self.period.getDataType().oclIsKindOf(Time)
		message: self.prefix()+ "The 'DataUse' expression assigned to the 'period' shall evaluate to a data instance of the 'Time' data type."
	}
}

//context Wait {
//removed
//Constraints
//Tester component for 'Wait' shall be known
	//constraint WaitTarget {
		//check:  (not self.componentInstance.oclIsUndefined()) and self.componentInstance.role = Tester
		//message: "The relation to a 'ComponentInstance' of a 'Wait' shall be set and refer to a 'Tester' component instance."
	//}
//}

context Quiescence {
//Constraints
//Exclusive use of gate reference or component instance
	constraint QuiescenceTarget {
		check:  self.gateReference.oclIsUndefined() or self.componentInstance.oclIsUndefined()
		message: self.prefix()+ "If a 'GateReference' is provided, a 'ComponentInstance' shall be not provided and vice versa."
	}
}

context Timer {
//removed
//Constraints
//Initial state of a timerWhen a timer is defined, it is operationally in the state idle.
}


context TimerOperation {
//Constraints
//Timer operations on tester components only
	constraint TimerOperationComponentRole {
		check:  self.componentInstance.role.name = 'Tester'
		message: self.prefix()+ "A 'TimerOperation' shall be performed only on a 'ComponentInstance' in the role 'Tester'."
	}

}

context TimerStart {
//Constraints
//'Time' data type for period expression
	constraint TimerPeriodType {
		check:  self.period.getDataType().oclIsKindOf(Time)
		message: self.prefix()+ "The 'DataUse' expression assigned to the 'period' shall evaluate to a data instance of the 'Time' data type."
	}
}

context GateReference {
//Constraints
//Gate instance of the referred component instance
	constraint GateInstanceReference {
		check:  self.component.type.gateInstance->contains(self.gate)
		message: self.prefix()+ "The referred 'GateInstance' shall be contained in the 'ComponentType' of the referred 'ComponentInstance'."
	}
}

context Connection {
//Constraints
//Self-loop connections are not permitted
	constraint NoSelfLoop {
		check:  self.endPoint->forAll(e1 | self.endPoint->one(e2 | 
					e1.gate = e2.gate 
				and e1.component = e2.component))
		message: self.prefix()+"The 'endPoint's of a 'Connection' shall not be the same. Two endpoints are the same if both, the referred 'ComponentInstance's and the referred 'GateInstance's, are identical."
	}
//Consistent type of a connection
	constraint ConsistentConnectionType {
		check:  self.endPoint->at(0).gate.type = self.endPoint->at(1).gate.type
		message: self.prefix()+"The 'GateInstance's of the two 'endPoint's of a 'Connection' shall refer to the same 'GateType'."
	}

}


context TestConfiguration {
//Constraints
//'TestConfiguration' and components roles
	constraint ComponentRoles {
		check:  self.componentInstance->exists(c | c.role.name = 'Tester') 
			and self.componentInstance->exists(c | c.role.name = 'SUT')
		message: self.prefix()+"A 'TestConfiguration' shall contain at least one 'Tester' and one 'SUT' 'ComponentInstance'."
	}
//Only 'Connection's between own 'ComponentInstance's
	constraint OwnedComponents {
		check:  self.connection->forAll(c | 
					self.componentInstance->contains(c.endPoint->at(0).component)
				and	self.componentInstance->contains(c.endPoint->at(1).component))
		message: self.prefix()+"A 'TestConfiguration' shall only contain 'Connection's between gates of its own 'ComponentInstance's."
	}


//Minimal 'TestConfiguration'
	constraint MinimalTestConfiguration {
		check:  self.connection->exists(c | 
					(c.endPoint->at(0).component.role.name = 'Tester' 
				 and c.endPoint->at(1).component.role.name = 'SUT')	
		 	 	 or (c.endPoint->at(0).component.role.name = 'SUT' 
		 	 	 and c.endPoint->at(1).component.role.name = 'Tester'))
		message: self.prefix()+"Each 'TestConfiguration' shall specify at least one 'Connection' that connects a 'GateInstance' of a 'ComponentInstance' in the role 'Tester' with a 'GateInstance' of a 'ComponentInstance' in the role 'SUT'."
	}
//At most one connection between any two 'GateInstance'/'ComponentInstance' pairs
	constraint UniqueConnections {
		check:  self.connection->forAll(c1 | self.connection->one(c2 |
					(c1.endPoint->at(0).component = c2.endPoint->at(0).component
				 and c1.endPoint->at(0).gate = c2.endPoint->at(0).gate
				 and c1.endPoint->at(1).component = c2.endPoint->at(1).component
				 and c1.endPoint->at(1).gate = c2.endPoint->at(1).gate)

				 or (c1.endPoint->at(1).component = c2.endPoint->at(0).component
				 and c1.endPoint->at(1).gate = c2.endPoint->at(0).gate
				 and c1.endPoint->at(0).component = c2.endPoint->at(1).component
				 and c1.endPoint->at(0).gate = c2.endPoint->at(1).gate
				 )))
		message: self.prefix()+"Given the set of 'Connection's contained in a 'TestConfiguration'. There shall be no two 'Connection's containing 'GateReference's that in turn refer to identical pairs of 'GateInstance'/'ComponentInstance'."
	}

}

context Block {
//Constraints
//Guard shall evaluate to Boolean
	constraint GuardType {
		check: 	self.`guard`->forAll(g | g.expression.oclIsUndefined()
			 or g.expression.getDataType().name = 'Boolean')
		message: self.prefix()+"The type of 'guard' shall be 'Boolean'."
	}
}

context BoundedLoopBehaviour {
//Constraints
//No guard constraint
	constraint BoundedGuard {
		check: not self.block.`guard`.oclIsUndefined()
		message: self.prefix()+"The 'Block' of a 'BoundedLoopBehaviour' shall not have a 'guard'."
	}
//cannot be expressed, may need to be removed
//Iteration number shall be countable and positive
//  The expression assigned to the 'numIteration' property shall evaluate to a countable 'SimpleDataInstance' of an arbitrary user-defined data type, e.g. a positive Integer value.

}


context AlternativeBehaviour {
//Constraints
//Number of 'Block's
	constraint AlternativeBlockCount {
		check:  self.block->size() > 1
		message: self.prefix()+"An 'AlternativeBehaviour' shall contain at least two 'Block's."
	}
//First behaviour of 'Block's
	constraint FirstBlockBehaviour {
		//TODO: update the description of tester input event
		//tester input event: 
		// - Interaction with target.gate.component.role.name = 'Tester'
		// - TimerTimeout
		// - Quiescence
		//TODO: update with clarification
		// - not transitive - the first behaviour has to be one of the 
		//   tester input events, directly within the block of the alternative 
		//   nesting is excluded
		//TODO: update with clarification
		// - tester input event interaction shall orginiate at the SUT
		check:	self.block->forAll(b | b.behaviour->first().isTesterInputEvent())
		message: self.prefix()+"Each block of an 'AlternativeBehaviour' shall start with a tester-input event."
	}

}

context ConditionalBehaviour {
//Constraints
//Guard for 'ConditionalBehaviour' with single block
	constraint ConditionalFirstGuard {
		check:  self.block->size() > 1
		 or not self.block->first().`guard`.oclIsUndefined()
		message: self.prefix()+"If there is only one 'Block' specified, it shall have a 'guard'."
	}
//Possible else block for 'ConditionalBehaviour' with multiple blocks
	constraint ConditionalLastGuard {
		check:  self.block->size() = 1 
			 or self.block->forAll(b |
					b = self.block->last()
				 or not b.`guard`.oclIsUndefined())
		message: self.prefix()+"All 'Block's specified, except the last one, shall have a 'guard'."
	}

//removed
//First 'AtomicBehaviour' allowed
/*
	constraint ConditionalFirstBehaviour {
		check:  self.block->forAll(b | not b.behaviour.first().isTesterInputEvent())
		message: self.prefix()+"The first 'AtomicBehaviour' of any 'Block' of a 'ConditionalBehaviour' shall not be a tester-input event."
	}
*/
}


context ParallelBehaviour {
//Constraints
//Number of blocks in 'ParallelBehaviour'
	constraint ParallelBlockCount {
		check:  self.block->size() > 1
		message: self.prefix()+"There shall be at least two 'Block's specified."
	}
}

context ExceptionalBehaviour {
//Constraints
//No guard
//removed
//	constraint ExceptionalGuard {
//		check:  self.block.`guard`.oclIsUndefined()
//		message: "The 'Block' shall have no guard."
//	}

//First 'AtomicBehaviour' in block allowed
//  Each block of an 'ExceptionalBehaviour' shall start with a tester-input event. 
	constraint FirstExceptionalBehaviour {
		check:	self.block.behaviour->first().isTesterInputEvent()
		message: self.prefix()+"The block of an 'ExceptionalBehaviour' shall start with a tester-input event."
	}

//Guarded component shall be a 'Tester' component
	constraint ExceptionalGuardedComponent {
		check:  self.guardedComponent.oclIsUndefined() 
		  	 or self.guardedComponent.role.name = 'Tester'
		message: self.prefix()+"The 'guardedComponent' shall refer to a 'ComponentInstance' with the role of 'Tester'."
	}

}

context PeriodicBehaviour {
//Constraints
//Removed
//First 'AtomicBehaviour' allowed
//  The first 'AtomicBehaviour' of any 'Block' of a 'PeriodicBehaviour' shall not be a tester-input event.
//'Time' data type for period expression
	constraint PeriodType {
		check:  self.period->forAll(p | p.expression.getDataType().oclIsKindOf(Time))
		message: self.prefix()+"The 'DataUse' expression assigned to the 'period' shall evaluate to a data instance of the 'Time' data type."
	}

}

context VerdictAssignment {
//Constraints
//Verdict of type 'Verdict'
	constraint VerdictType {
		check:  self.verdict.getDataType().name = 'Verdict'
		message: self.prefix()+"The 'verdict' shall evaluate to a, possibly predefined, instance of a 'SimpleDataInstance' of data type 'Verdict'."
	}

}

context Assertion {
//Constraints
//Boolean condition
	constraint AssertionOtherwise {
		check:  self.condition.getDataType().name = 'Boolean'
		message: self.prefix()+"The 'condition' shall evaluate to predefined 'DataType' 'Boolean'."
	}
//Otherwise of type 'Verdict'
	constraint AssertionVerdict {
		check:  self.otherwise.oclIsUndefined() or self.otherwise.getDataType().name = 'Verdict'
		message: self.prefix()+"The 'otherwise' shall evaluate to a, possibly predefined, instance of a 'SimpleDataInstance' of data type 'Verdict'."
	}

}

context Interaction {
//Constraints
//Gate references of an interaction shall be different
//	constraint DistinctInteractionGates {
//		//removed - already covered under connection and connected gates
//		check:  not self.target->exists(t | t.targetGate = self.sourceGate)
//		message: self.prefix()+"All 'GateReference's that act as source or target(s) of an 'Interaction' shall be different from each other."
//	}
//Gate references of an interaction shall be connected
	constraint ConnectedInteractionGates {
		check:	self.target.forAll(t | 
					self.getTestDescription().testConfiguration.connection->exists(c |
						(c.endPoint->at(0).gate = self.sourceGate.gate
					 and c.endPoint->at(0).component = self.sourceGate.component 
					 and c.endPoint->at(1).gate = t.targetGate.gate
					 and c.endPoint->at(1).component = t.targetGate.component)
						
					 or (c.endPoint->at(1).gate = self.sourceGate.gate 
					 and c.endPoint->at(1).component = self.sourceGate.component 
					 and c.endPoint->at(0).gate = t.targetGate.gate
					 and c.endPoint->at(0).component = t.targetGate.component)))
		message: self.prefix()+"The 'GateReference's that act as source or target(s) of an 'Interaction' shall be interconnected by a 'Connection'."
	}
//Type of interaction argument
	constraint InteractionArgumentAndGateType {
		check:  (self.argument.oclIsKindOf(AnyValue) and self.argument.dataType.oclIsUndefined()) 
			 or (self.sourceGate.gate.type.dataType->includes(self.argument.getDataType())
	   		 and self.target.forAll(t | t.targetGate.gate.type.dataType->includes(self.argument.getDataType()))) 
		message: self.prefix()+"The 'DataUse' specification referred to in the 'argument' shall match one of the 'DataType's referenced in the 'GateType' definition of the 'GateInstance's referred to by the source and target 'GateReference's of the 'Interaction'."
	}
//Use of variables in the 'argument' specification
	constraint InteractionArgumentVariableUse {
		check:  (not self.argument.oclIsKindOf(VariableUse)
		 	  or (self.sourceGate.component = self.argument.componentInstance 
		 	   or self.target->forAll(t | 
		 	   		t.targetGate.component = self.argument.componentInstance)))
			 
			 and self.argument.argument->forAll(a | 
			 		not a.dataUse.oclIsKindOf(VariableUse) 
			 	 or (self.sourceGate.component = a.dataUse.componentInstance 
		 		  or self.target->forAll(t | 
		 	   			t.targetGate.component = a.dataUse.componentInstance)))
			 	 
		  	 and self.argument.argument->closure(a | a.dataUse.argument)->forAll(a | 
		  	 		not a.dataUse.oclIsKindOf(VariableUse)
			 	 or (self.sourceGate.component = a.dataUse.componentInstance 
		 		  or self.target->forAll(t | 
		 	   			t.targetGate.component = a.dataUse.componentInstance)))
		
		message: self.prefix()+"The use of 'Variable's in the 'DataUse' specification shall be restricted to 'Variable's of 'ComponentInstance's that participate in this 'Interaction' via the provided 'GateReference's."
	}

//Matching data type for 'argument' and 'variable'
	constraint InteractionArgumentAndVariableType {
		check:  self.target.forAll(t | 
					t.variable.oclIsUndefined()
				 or t.variable.dataType = self.argument.getDataType()) 
		message: self.prefix()+"The 'DataUse' specification of the 'argument' and the referenced 'Variable' of any 'Target' shall refer to the same 'DataType'."
	}

//'DataType' for 'AnyValue' as 'argument'
//	constraint AnyValueDataType {
//		check:  self.argument.oclIsKindOf(AnyValue)
//			and (self.argument.argument.isEmpty() or not self.argument.dataType.oclIsUndefined())
//		message: self.prefix()+"If 'AnyValue' is used as 'argument' and of the 'Interaction' and the optional 'ParameterBinding's are provided, the 'dataType' of 'AnyValue' shall be specified."
//	}

}

context Target {
//Constraints
//Variable and target gate of the same component instance
	constraint TargetComponent {
		check:  self.variable.oclIsUndefined() 
			 or self.targetGate.component.type.variable->contains(self.variable)
		message: self.prefix()+"The referenced 'Variable' shall exist in the same 'ComponentType' as the 'GateInstance' that is referred to by the 'GateReference' of the 'targetGate'."
	}
//Variable of a tester component only
	constraint TargetVariableComponentRole {
		check:  self.variable.oclIsUndefined() 
			 or self.targetGate.component.role.name = 'Tester'
		message: self.prefix()+"If a 'Variable' is specified, the 'ComponentInstance' referenced by 'targetGate' shall be in the role 'Tester'."
	}

}

context TestDescriptionReference {
//Constraints
//Number of actual parameters
	constraint ParameterCount {
		check:  self.actualParameter->size() = self.testDescription.formalParameter->size()
		message: self.prefix()+"The number of actual parameters in the 'TestDescriptionReference' shall be equal to the number of formal parameters of the referenced 'TestDescription'."
	}

//No use of variables in actual parameters
	constraint NoVariables {
		check: 	self.actualParameter.forAll(p | 
					not p.oclIsKindOf(VariableUse)
				and p.argument->forAll(a | not a.dataUse.oclIsKindOf(VariableUse))
		 		and p.argument->closure(a | a.dataUse.argument)->forAll(a | not a.dataUse.oclIsKindOf(VariableUse)))
		 		 
		message: self.prefix()+"The 'DataUse' expressions used to describe actual parameters shall not contain variables directly or indirectly."
	}

//Matching parameters
	constraint TestDescriptionParameters {
		check:  self.actualParameter.forAll(ap |
					self.testDescription.formalParameter->size() > self.actualParameter->indexOf(ap) 
				and ap.getDataType() = self.testDescription.formalParameter->at(self.actualParameter.indexOf(ap)).dataType)
		message: self.prefix()+"The actual parameter AP[i] of index i in the ordered list of 'actualParameter's shall match 'DataType' of the 'FormalParameter' FP[i] of index i in the ordered list of formal parameters of the referenced 'TestDescription'."
	}

//Restriction to 1:1 component instance bindings
	constraint UniqueComponentBindings {
		check:  self.componentInstanceBinding->isEmpty() 
		 	 or self.componentInstanceBinding->forAll(b | self.componentInstanceBinding->one(c | c.formalComponent = b.formalComponent or c.actualComponent = b.actualComponent))
		message: self.prefix()+"If component instance bindings are provided, the component instances referred to in the bindings shall occur at most once for the given test description reference."
	}

//redundat: add containment constraint similar to the one for gates, see ComponentInstanceBinding below
//	  - bound compoent instances need to be contained in the test configurations used by
//		  the corresponding test descriptions, with disntictions for formal and actual components 

/*Compatible test configurations 
  The test configuration TConf2 of the referenced (invoked) test description shall be compatible with the test configuration TConf1 of the referencing (invoking) test description under the provision of a list of bindings between component instances in TConf1 and TConf2. Compatibility is then defined in the following terms:
  All component instances in TConf2 can be mapped to component instances of TConf1.A component instance B of test configuration TConf2 can be mapped to a component instance A of test configuration TConf1if and only if:
  a)	there is a binding pair (A, B) provided;
  b)	A and B refer to the same component type; and
  c)	A and B have the same component instance role {SUT, Tester} assigned.
  All connections between component instances in TConf2 exist also between the mapped component instances in TConf1 and the type of a connection in TConf2 equals the type of the related connection in TConf1.Two connections of the two test configurations are equal if and only if the same gate instances are used in the definition of the gate references of the connections.
  NOTE 1:	The compatibility between test configurations is defined asymmetrically. That is, if TConf2 is compatible with TConf1, it does not imply that TConf1is compatible with TConf2. If TConf2 is compatible with TConf1, it is said that TConf2 is a sub-configuration of TConf1 under a given binding.
  NOTE 2:	If two test configurations are equal, then they are also compatible.
*/
	constraint CompatibleConfiguration {
				//same configuration with no bindings
		check:	(self.getTestDescription().testConfiguration = self.testDescription.testConfiguration 
			 and self.componentInstanceBinding->isEmpty())
			 //component bindings for all components exist
		 	 or	(self.testDescription.testConfiguration.connection->forAll(c | 
						self.componentInstanceBinding->exists(i | 
							i.formalComponent = c.endPoint->at(0).component) 
					and self.componentInstanceBinding->exists(i |
							i.formalComponent = c.endPoint->at(1).component)
				 	//provided -> select matched -> check matched
					and self.getTestDescription().testConfiguration.connection->select(p | 
							(p.endPoint->at(0).component = self.componentInstanceBinding->select(i | 
								i.formalComponent = c.endPoint->at(0).component)->first().actualComponent 
					 	 and p.endPoint->at(1).component = self.componentInstanceBinding->select(i | 
								i.formalComponent = c.endPoint->at(1).component)->first().actualComponent)
				 		 or (p.endPoint->at(1).component = self.componentInstanceBinding->select(i | 
								i.formalComponent = c.endPoint->at(0).component)->first().actualComponent 
				 		 and p.endPoint->at(0).component = self.componentInstanceBinding->select(i | 
								i.formalComponent = c.endPoint->at(1).component)->first().actualComponent))->exists(m | 
								(m.endPoint->at(0).gate.type = c.endPoint->at(0).gate.type 
				 			 and m.endPoint->at(1).gate.type = c.endPoint->at(1).gate.type)
				 			 or (m.endPoint->at(0).gate.type = c.endPoint->at(1).gate.type 
				 			 and m.endPoint->at(1).gate.type = c.endPoint->at(0).gate.type))))
		message: self.prefix()+"The test configuration TConf2 of the referenced (invoked) test description shall be compatible with the test configuration TConf1 of the referencing (invoking) test description."
	}
}

context ComponentInstanceBinding {
//Constraints
//remove - redundant
//'ComponentInstance's from from referenced 'TestConfiguration's
//	constraint ComponentInstanceContainment {
//		check:  self.container().testDescription.testConfiguration.componentInstance->contains(self.formalComponent)
//			and	self.getTestDescription().testConfiguration.componentInstance->contains(self.actualComponent)
//		message: self.prefix()+"All formal 'ComponentInstance's shall be contained in the 'TestConfiguration' of the invoked 'TestDescription' and all actual 'ComponentInstance's  shall be contained in the 'TestConfiguration' of the invoking 'TestDescription'."
//	}

//Matching component types
	constraint BindingComponentTypes {
		check:  self.formalComponent.type = self.actualComponent.type
		message: self.prefix()+"Both, the formal and the actual component instances, shall refer to the same 'ComponentType'."
	}
//Matching component instance roles
	constraint BindingComponentRoles {
		check:  self.formalComponent.role = self.actualComponent.role
		message: self.prefix()+"Both, the formal and the actual component instances, shall have the same 'ComponentInstanceRole' assigned to."
	}
}



context ActionBehaviour {
//Constraints
//'ActionBehaviour' on 'Tester' components only
	constraint ActionBehaviourComponentRole {
		check:  self.componentInstance.oclIsUndefined() 
			 or self.componentInstance.role.name = 'Tester'
		message: self.prefix()+"The 'ComponentInstance' that an 'ActionBehaviour' refers to shall be of role 'Tester'."
	}

}

context ActionReference {
//Constraints
//Matching parameters
	constraint ActionParameters {
		check:  self.actualParameter->forAll(ap | 
					ap.getDataType() = self.action.formalParameter->at(self.actualParameter->indexOf(ap)).dataType) 
		message: self.prefix()+"The actual parameter AP[i] of index i in the ordered set of 'actualParameter's shall match the 'DataType' of the 'FormalParameter' FP[i] of index i in the ordered set of formal parameters of the referenced 'Action'."
	}

}

context Assignment {
//Constraints
//Known component instance
	constraint AssignmentComponent {
		//TODO: update syntax? current syntax flexibility allows validation!
		check:  not self.componentInstance.oclIsUndefined()
		message: self.prefix()+"The property 'componentInstance' shall be set to identify the 'Variable' in this 'Assignment'."
	}
//Matching data type
	constraint AssignmentDataType {
		check:  self.expression.getDataType() = self.variable.dataType
		message: self.prefix()+"The provided 'DataUse' expression shall match the 'DataType' of the referenced 'Variable'."
	}
}

//added a constraint that connections can only be established - see above 
//	  between gates of components from the same test configuration
//	  possibly also regarding components owning the connected gates 
//	  - the latter already covered by the constraint under GateReference








context Assignment {
//Constraints
//Known component instance
	constraint AssignmentComponent {
		//TODO: update syntax? current syntax flexibility allows validation!
		check:  not self.componentInstance.oclIsUndefined()
		message: self.prefix()+"The property 'componentInstance' shall be set to identify the 'Variable' in this 'Assignment'."
	}
//Matching data type
	constraint AssignmentDataType {
		check:  self.expression.getDataType() = self.variable.dataType
		message: self.prefix()+"The provided 'DataUse' expression shall match the 'DataType' of the referenced 'Variable'."
	}
}
