behavior arduino;
open class Project{	
	@main
	def void main() {
		'main'.log();
		self.sketch.block.execute();
	}
	
	@init
	def void initializeModel(String input) {
	}
}
open class Module{
	//the model state is defined in the ecore file with 'dynamic' annotation
	//Integer level;
	def Project getProject() {
		'get the project of the module'.log();
		Project project := null;
		EObject current := self.eContainer();
		while (current != null) {
			if (current.oclIsTypeOf(arduino::Project)) {
				project := current.oclAsType(arduino::Project);
				result := project;
			}
			current := current.eContainer();
		}
		result := project;
	}
}
open class PushButton extends ModuleAspect {
	
	@step
	def void press() {
		'press button'.log();
		self.level := 1;
		for (wait in self.getProject().sketch.eAllContents() ->filter(arduino::WaitFor)){
			if (wait.module = self){
				wait.setActiavted();
			}
		}
	}
	
	@step
	def void release() {
		'release button'.log();
		self.level := 0;
	}
}

open class Sketch {
	def void execute() {
		'execute sketch'.log();
		while(true) {
			self.block.execute();
		}
	}
}

open class Block {
	def void execute() {
		'execute block'.log();
		for (i in self.instructions){
			i.execute();
		}
	}
}

open class Instruction {
	def void execute() {
		'execute instruction'.log();
	}
	
	def void finalize() {
	}
}

open class Control extends Instruction {
	@step
	@OverrideAspectMethod
	def void execute() {
		'execute control instruction'.log();
	}
}

open class If extends Control {
	@step
	@OverrideAspectMethod
	def void execute() {
		'execute if instruction'.log();
		int res:=0;
		if (self.condition.oclIsTypeOf(arduino::UnaryExpression)){
			res := self.condition.oclAsType(arduino::UnaryExpression).evaluate();
		}else if (self.condition.oclIsTypeOf(arduino::BinaryExpression)){
			res := self.condition.oclAsType(arduino::BinaryExpression).evaluate();
		}else if (self.condition.oclIsTypeOf(arduino::ModuleGet)){
			res := self.condition.oclAsType(arduino::ModuleGet).evaluate();
		}else if (self.condition.oclIsTypeOf(arduino::Constant)){
			res := self.condition.oclAsType(arduino::Constant).evaluate();
		}
		if (res != 0) {
			self.block.execute();
		} else if (self.elseBlock != null) {
			self.elseBlock.execute();
		}
	}
}

open class While extends Control {
	@step
	@OverrideAspectMethod
	def void execute() {
		'execute while instruction'.log();
		while (self.condition.evaluate() != 0) {
			self.block.execute();
		}
	}
}

open class ModuleSet extends Instruction {
	@step
	@OverrideAspectMethod
	def void execute() {
		'execute moduleSet instruction'.log();
	}
}

open class SetLed extends ModuleSet {
	@step
	@OverrideAspectMethod
	def void execute() {
		'execute setLed instruction'.log();
		self.led.level := self.value.evaluate();
		if (self.led.level = 1){
			'led is turned on'.log();
		}else{
			'led is turned off'.log();
		}
	}
} 

open class Delay extends Instruction{
	@step
	@OverrideAspectMethod
	def void execute() {
		'execute delay instruction'.log();
		//Thread.sleep(self.value);
		'delaying'.log();
	}
}

open class WaitFor extends Instruction {
	Boolean waiting := false;
	Boolean moduleActivated := false;
	
	@step
	@OverrideAspectMethod
	def void execute() {
		'execute waitFor instruction'.log();
		if (self.value != null and self.isValidated()) {
			self.moduleActivated := false;
			self.waiting := false;
		}else{
			self.waiting := true;
			while (not(self.moduleActivated and self.isValidated())) {
				self.moduleActivated := false;
				self.loop();
			}
			self.moduleActivated := false;
			self.waiting := false;
		}
	}
	
	 def Boolean isValidated() {
	 	if (self.value = null or self.module.level = self.value.value){
	 		result := true;
	 	}else{
	 		result := false;
	 	}
	}
	
	@step
	def void loop() {
		//Thread.sleep(100);
		'waiting'.log();
	}
	
	def void setActivated() {
		if (self.waiting) {
			self.moduleActivated := true;
		}
	}
}

open class UnaryExpression{
	@step
	def int evaluate() {
		'evaluate Unary Expression'.log();
		int res := 0;
		Operand operand := self.operand.evaluate();
		if (self.operator = arduino::UnaryOperatorKind::minus) {
			res -= operand;
		}else if (self.operator = arduino::UnaryOperatorKind::neg) {
			if (operand = 0) {
				res := 1;
			}else{
				res := 0;
			}
		}
		result := res;
	}
}

open class BinaryExpression{
	@step
	def int evaluate() {
		'evaluate Binary Expression'.log();
		int res := 0;
		Operand iLeft := self.left.evaluate();
		Operand iRight := self.right.evaluate();
		if (self.operator = arduino::BinaryOperatorKind::div) {
			res := iLeft / iRight;
		} else if (self.operator = arduino::BinaryOperatorKind::max) {
			res := Math.max(iLeft, iRight);
		} else if (self.operator = arduino::BinaryOperatorKind::min) {
			res := Math.min(iLeft, iRight);
		} else if (self.operator = arduino::BinaryOperatorKind::sub) {
			res := iLeft - iRight;
		} else if (self.operator = arduino::BinaryOperatorKind::mul) {
			res := iLeft * iRight;
		} else if (self.operator = arduino::BinaryOperatorKind::add) {
			res := iLeft + iRight;
		} else if (self.operator = arduino::BinaryOperatorKind::lt) {
			if (iLeft < iRight){
				res := 1;
			} else {
				res := 0;
			}
		} else if (self.operator = arduino::BinaryOperatorKind::le) {
			if (iLeft <= iRight){
				res := 1;
			} else {
				res := 0;
			}
		} else if (self.operator = arduino::BinaryOperatorKind::eq) {
			if (iLeft = iRight){
				res := 1;
			} else {
				res := 0;
			}
		} else if (self.operator = arduino::BinaryOperatorKind::ge) {
			if (iLeft >= iRight){
				res := 1;
			} else {
				res := 0;
			}
		} else if (self.operator = arduino::BinaryOperatorKind::gt) {
			if (iLeft > iRight){
				res := 1;
			} else {
				res := 0;
			}
		} else if (self.operator = arduino::BinaryOperatorKind::neq) {
			if (iLeft != iRight){
				res := 1;
			} else {
				res := 0;
			}
		}
		result := res;
	}
}

open class Constant{
	@step
	def int evaluate() {
		'evaluate constant expression'.log();
		result := self.value;
	}
}

open class ModuleGet{
	@step
	def int evaluate() {
		'evaluate moduleGet Expression'.log();
		result := self.module.level;
	}
}
