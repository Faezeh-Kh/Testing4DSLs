-- @nsURI Ecore=http://www.eclipse.org/emf/2002/Ecore
-- @path TDL=/org.etsi.mts.tdl.model/model/tdl.ecore

module ecore2tdl;
create OUT : TDL from IN : Ecore;

helper def: tokenNames: Sequence(String) = Sequence {
	'exception' , 'Entity' , 'Configuration' , 'PICS' , 'constraints' , 'bind' 
	, 'containing' , '(' , ')' , 'optional' , '*' , 'then' , '+' , 'triggers' 
	, ',' , 'an' , 'execute' , '-' , '.' , '/' , 'as' , 'SUT' , 'at' , 'size' 
	, 'stop' , 'Note' , 'returns' , 'assigned' , ':' , 'receives' , ';' , '<' 
	, '!=' , 'conditions' , '=' , '>' , '?' , '@' , 'into' , 'default' , 'by' 
	, 'xor' , 'where' , 'quiet' , 'after' , 'attribute' , '[' , ']' , 'connect' 
	, 'a' , 'alternatively' , 'set' , 'replaced' , 'the' , 'component' , 'calls' 
	, 'associated' , 'Event' , 'to' , '{' , 'returned' , 'Initial' , '}' 
	, 'Constraint' , 'bindings' , 'run' , 'predefined' , 'Name' , 'Test' 
	, 'Procedure' , 'Expected' , 'ensure' , 'last' , 'test' , 'extends' , 'name' 
	, 'carrying' , 'some' , 'Action' , 'hidden' , 'for' , 'description' , 'Time' 
	, 'Gate' , 'timeout' , 'not' , 'now' , 'Component' , 'every' , 'derived' 
	, 'previous' , 'start' , 'perform' , 'false' , 'multiple' , 'merged' , 'Purpose' 
	, 'label' , 'with' , 'gate' , 'time' , 'Import' , 'mod' , 'optionally' , 'during' 
	, 'type' , 'occurs' , 'when' , 'else' , 'action' , 'if' , 'having' , 'waits' 
	, 'in' , 'is' , 'it' , 'Out' , 'Variant' , 'verdict' , 'Package' , 'terminate' 
	, 'Map' , 'wait' , 'Description' , 'In' , 'Implementation' , 'out' , 'Enumerated' 
	, 'indicating' , 'assert' , 'Structure' , 'event' , 'Final' , 'break' , 'within' 
	, 'Use' , 'Reference' , 'trigger' , 'Annotation' , 'sends' , 'Type' , 'behaviour' 
	, 'Predefined' , 'first' , 'entity' , '<=' , 'argument' , 'instance' , 'before' 
	, 'several' , 'while' , 'Template' , 'that' , 'TestDescription' , 'interrupt' 
	, 'only' , 'few' , 'create' , 'from' , 'all' , '==' , 'otherwise' , 'new' , 'accepts' 
	, 'Objective' , '->' , 'true' , 'mapped' , 'Collection' , 'omit' , '>=' , 'no' 
	, 'Tester' , 'Message' , 'configuration' , 'responds' , 'point' , 'Function' , 'timer' 
	, 'times' , 'parallel' , 'and' , 'of' , 'parameter' , 'repeat' , 'value' , 'on' , 'or' 
	, 'any' , 'Exception' , 'contained' , 'corresponding' , 'References' , 'response' 
	, 'Signature' , 'variable' , 'uses' , 'objectives'
}; 
helper def: enums: Set (Ecore!EEnum)= Ecore!EEnum->allInstances()->asSet();
helper def: enumLiterals: Set (Ecore!EEnumLiteral) = thisModule.enums->collect(e | e.eLiterals);
helper context Ecore!EPackage def: basicDataTypes: Set(Ecore!EDataType) = Ecore!EDataType->allInstances()->
	select(type | not type.oclIsKindOf(Ecore!EEnum))->asSet();


helper def: dynamicAnnotationType: TDL!AnnotationType = OclUndefined;

helper context Ecore!EStructuralFeature def: isDynamicFeature: Boolean = 
	if (self.eAnnotations->select(a | a.source = 'dynamic' or a.source = 'aspect')->notEmpty()) then true else false endif;

helper context Ecore!EClass def: isDynamicClass: Boolean = 
	if (self.eAnnotations->select(a | a.source = 'dynamic' or a.source = 'aspect')->notEmpty()) then true else false endif;

helper context Ecore!EClass def: getDynamicAnnotationType: TDL!AnnotationType =
	if (thisModule.dynamicAnnotationType.oclIsUndefined())
				   then thisModule.eAnnotation2annotationType()
				   else thisModule.dynamicAnnotationType
				   endif;

helper def: abstractAnnotationType: TDL!AnnotationType = OclUndefined;

helper context Ecore!EClass def: getAbstractAnnotationType: TDL!AnnotationType =
	if (thisModule.abstractAnnotationType.oclIsUndefined())
				   then thisModule.abstract2annotationType()
				   else thisModule.abstractAnnotationType
				   endif;
	
helper context Ecore!ENamedElement def: getValidName: String=
	if (thisModule.tokenNames.includes(self.name))
				then '_' + self.name
				else self.name
				endif;

rule simpleConcreteStaticClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.isEmpty() and not class.abstract and not class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule simpleConcreteDynamicClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.isEmpty() and not class.abstract and class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		annotation <- dynamicAnnotation),
		dynamicAnnotation: TDL!Annotation(
			key <- class.getDynamicAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule simpleAbstractStaticClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.isEmpty() and class.abstract and not class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		annotation <- abstractAnnotation),
		abstractAnnotation: TDL!Annotation(
			key <- class.getAbstractAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule simpleAbstractDynamicClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.isEmpty() and class.abstract and class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName),
		abstractAnnotation: TDL!Annotation(
			key <- class.getAbstractAnnotationType,
			annotatedElement <- type),
		dynamicAnnotation: TDL!Annotation(
			key <- class.getDynamicAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule featuredConcreteStaticClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.isEmpty()
								and not class.abstract
								and not class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif))
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule featuredConcreteDynamicClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.isEmpty()
								and not class.abstract
								and class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif),
		annotation <- dynamicAnnotation),
		dynamicAnnotation: TDL!Annotation(
			key <- class.getDynamicAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule featuredAbstractStaticClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.isEmpty()
								and class.abstract
								and not class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif),
		annotation <- abstractAnnotation),
		abstractAnnotation: TDL!Annotation(
			key <- class.getAbstractAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}

rule featuredAbstractDynamicClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.isEmpty()
								and class.abstract
								and class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif)),
		abstractAnnotation: TDL!Annotation(
			key <- class.getAbstractAnnotationType,
			annotatedElement <- type),
		dynamicAnnotation: TDL!Annotation(
			key <- class.getDynamicAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}

rule concreteInheritedStaticClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.notEmpty()
								and not class.abstract
								and not class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif),
		extension <- class.eSuperTypes -> collect (st | thisModule.superClass2extension(st)))
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}

rule concreteInheritedDynamicClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.notEmpty()
								and not class.abstract
								and class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif),
		extension <- class.eSuperTypes -> collect (st | thisModule.superClass2extension(st)),
		annotation <- dynamicAnnotation),
		dynamicAnnotation: TDL!Annotation(
			key <- class.getDynamicAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}

rule abstractInheritedStaticClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.notEmpty()
								and class.abstract
								and not class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <- class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif),
		extension <- class.eSuperTypes -> collect (st | thisModule.superClass2extension(st)),
		annotation <- abstractAnnotation),
		abstractAnnotation: TDL!Annotation(
			key <- class.getAbstractAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}

rule abstractInheritedDynamicClass2Type{
	from class: Ecore!EClass (class.eAllStructuralFeatures.notEmpty() 
								and class.eSuperTypes.notEmpty()
								and class.abstract
								and class.isDynamicClass)
	to type: TDL!StructuredDataType(
		name <-class.getValidName,
		member <- class.eStructuralFeatures-> collect(feature | 
				if (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
					then thisModule.dynamicFeature2annotatedMember(feature)
					else thisModule.staticFeature2member(feature)
					endif),
		extension <- class.eSuperTypes -> collect (st | thisModule.superClass2extension(st))),
		abstractAnnotation: TDL!Annotation(
			key <- class.getAbstractAnnotationType,
			annotatedElement <- type),
		dynamicAnnotation: TDL!Annotation(
			key <- class.getDynamicAnnotationType,
			annotatedElement <- type)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}

lazy rule superClass2extension{
	from class: Ecore!EClass
	to parent : TDL!Extension(
		extending <- class
	)
}

lazy rule staticFeature2member{
	from feature: Ecore!EStructuralFeature (feature.eAnnotations.isEmpty() or 
			(feature.eAnnotations.notEmpty() and (not feature.isDynamicFeature)))
	to member: TDL!Member(
		name <- feature.getValidName,
		dataType <- if (feature.oclIsKindOf(Ecore!EAttribute) and thisModule.enums->excludes(feature.eType))
					then  thisModule.dataType2simpleType(feature.eType)
					else feature.eType
					endif)
}
lazy rule dynamicFeature2annotatedMember{
	from feature: Ecore!EStructuralFeature (feature.eAnnotations.notEmpty() and feature.isDynamicFeature)
	to member: TDL!Member(
		name <- feature.getValidName,
		dataType <- if (feature.oclIsKindOf(Ecore!EAttribute) and thisModule.enums->excludes(feature.eType))
					then  thisModule.dataType2simpleType(feature.eType)
					else feature.eType
					endif,
		annotation <- memberAnnotation),
		memberAnnotation: TDL!Annotation(
			key <- if (thisModule.dynamicAnnotationType.oclIsUndefined())
				   then thisModule.eAnnotation2annotationType()
				   else thisModule.dynamicAnnotationType
				   endif,
			annotatedElement <- member)
}
unique lazy rule eAnnotation2annotationType{
	from feature: Ecore!EStructuralFeature
	to annotation: TDL!AnnotationType(
		name <- 'dynamic')
	do{
		thisModule.dynamicAnnotationType <- annotation;
	}
}
unique lazy rule abstract2annotationType{
	from class: Ecore!EClass
	to annotation: TDL!AnnotationType(
		name <- 'abstract')
	do{
		thisModule.abstractAnnotationType <- annotation;
	}
}
rule enum2simpleType{
	from enum: Ecore!EEnum
	to type : TDL!SimpleDataType(
		name <- enum.getValidName) 
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule enumLiteral2simpleDataInstance{
	from enumLiteral: Ecore!EEnumLiteral
	to dataInstance: TDL!SimpleDataInstance(
		name <- enumLiteral.getValidName,
		dataType <- enumLiteral.eEnum)
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(dataInstance.name.toString());
	}
}
unique lazy rule dataType2simpleType{
	from dataType: Ecore!EDataType
	to type : TDL!SimpleDataType(
		name <- dataType.getValidName )
	do{
		thisModule.tokenNames <- thisModule.tokenNames.append(type.name.toString());
	}
}
rule tdlPackage{
	from package: Ecore!EPackage
	to dslTypesPackage: TDL!Package(
		name <- package.name.concat('SpecificTypes'),
		packagedElement <- package.eClassifiers.
							union(thisModule.enums).
							union(thisModule.enumLiterals).
							append(thisModule.dynamicAnnotationType).
							append(thisModule.abstractAnnotationType).
							union(package.basicDataTypes->collect(t | thisModule.dataType2simpleType(t))))
}